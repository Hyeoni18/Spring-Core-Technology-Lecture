<h3>스프링 프레임워크 핵심 기술</h3>

boot는 프레임워크가 아니라 툴이야

1/ 스프링 IOC 컨테이너와 빈

Inversion Of Control 의존관계주입.

어떤객체가 (ex, Service클래스 타입의 객체가) 가 사용할 객체 (ex.Repository)를 의존관계를 new Repository() 로 생성해서 쓰는게 아니라 어떤 장치 (ex.생성자) 를 사용해서  주입을 받아 사용하는 방법을 IOC라고 한다.

스프링 IOC 컨테이너의 최상위에 있는 인터페이스는 BeanFactory 라는 인터페이스임. 가장 핵심적인 클래스이기도 함. 다양한 라이프 사이클을 통해 스프링이 여러가지 기능들을 제공할 수 있는거야. 컨테이너 내부의 빈들을 가공한다던가 등. 실제로 어떤 빈팩토리를 사용해서 xml 설정과 자바 설정을 어떤 식으로 사용할 수 있었는지. 스프링 부트가 없을 때. 

컨테이너 안에 들어있는 객체를 빈이라고 함.

컨테이너라고 부르는 이유는 IOC 기능을 제공하는 빈들을 담고 있기 때문이야.

일반 VO는 IOC 컨테이너에 존재하는 빈은 아니야, getter, setter 가 있으니까 자바 빈이라고는 할 수 있겠지만. (자바 빈 스펙을 준수하니까. 한 번 찾아보기)

왜 service 와 repository 는 빈으로 등록했는가. 의존성 주입 때문이기도 하고, bean 의 scope 때문이기도 함. 애플리케이션 전반적으로 bookservice 인스턴스는 하나만 만들어서 사용되면 돼. 이렇게 싱글톤으로 객체를 만들어 사용하고 싶을 때 사용하면 편함. ioc 는 기본적으로 싱글톤 scope으로 등록됨. 

싱글톤은 하나만 만들어서 사용, 프로포토타입은 매번 다른 객체를 사용.

기본적으로 빈을 등록할 때 아무런 어노테이션을 붙이지 않았다면 싱글톤으로 등록됨. 그러니까 우리가 인스턴스를 받아서 쓸 경우 모두 같은 객체일거야. 싱글톤은 하나랬으니까. 메모리 부분에서도 효율적이지. 이미 컨테이너 안에 미리 만들어놨던 객체를 사용하기 때문에 런타임시에 성능 최적화에도 유리해. 프로포토타입은 매번 만들어서 사용하거든. 특히, DB나 일을 하는 Repository 같은 경우는 만드는데 비용이 비싼 편인데 싱글톤으로 쉽게 사용할 수 있다면 큰 장점인거야. 

그밖에도. 의존성 관리나 라이프 사이클 인터페이스를 지원받는게 빈으로 등록했을 때 장점이야.

라이프 사이클은 예를들어, 어떤 빈이 만들어졌을 때 나는 뭔가 추가적인 작업을 하고 싶다. PostConstruct 어노테이션 처럼. 라이프 사이클 콜백에 해당하는 어노테이션을 찾아 메소드가 호출되는거야. 굉장히 다양해.

//source

우리는 bookrepository 를 구현하지 않고서는 bookservice 만 테스트를 할 수 없어. bookservice 가 코드가 있어도 사용하는 bookrepository 가 null을 return 하니까. 이게 의존성에 대한 문제야. 의존성을 가진 bookservice 는 단위테스트를 하기 힘들어. 

그런데, 여기서 직접 의존성을 주입한 경우라면 테스트가 더더욱 힘들어지는거야. 의존성을 바꿔줄 수 없으니까. 그나마 다행으로 의존성 주입을 받을 수 있도록 코드를 생성했기에 테스트할 때 얼마든지 가짜 객체를 만들어서 의존성 주입을 할 수 있어.

스프링 IOC 컨테이너에 중요한 인터페이스가 2개 있는데, 하나는 BeanFactory 이고, 실질적으로 가장 많이 쓸 빈팩토리는 ApplicationContext 임. 얘도 빈팩토리를 상속받아서 빈팩토리이긴 한데, 추가적으로 [ApplicationEventPublisher](https://docs.spring.io/spring-framework/docs/5.0.8.RELEASE/javadoc-api/org/springframework/context/ApplicationEventPublisher.html), [BeanFactory](https://docs.spring.io/spring-framework/docs/5.0.8.RELEASE/javadoc-api/org/springframework/beans/factory/BeanFactory.html), [EnvironmentCapable](https://docs.spring.io/spring-framework/docs/5.0.8.RELEASE/javadoc-api/org/springframework/core/env/EnvironmentCapable.html), [HierarchicalBeanFactory](https://docs.spring.io/spring-framework/docs/5.0.8.RELEASE/javadoc-api/org/springframework/beans/factory/HierarchicalBeanFactory.html), [ListableBeanFactory](https://docs.spring.io/spring-framework/docs/5.0.8.RELEASE/javadoc-api/org/springframework/beans/factory/ListableBeanFactory.html), [MessageSource](https://docs.spring.io/spring-framework/docs/5.0.8.RELEASE/javadoc-api/org/springframework/context/MessageSource.html), [ResourceLoader](https://docs.spring.io/spring-framework/docs/5.0.8.RELEASE/javadoc-api/org/springframework/core/io/ResourceLoader.html), [ResourcePatternResolver](https://docs.spring.io/spring-framework/docs/5.0.8.RELEASE/javadoc-api/org/springframework/core/io/support/ResourcePatternResolver.html)

가 있다.



2/ ApplicationContext와 다양한 빈 설정 방법

SpringBoot Project 생성 후 BookService, BookRepository 생성

```java
public class BookRepository {
}
```

```java
public class BookService {

    BookRepository bookRepository;

    public void setBookRepository(BookRepository bookRepository) {
        this.bookRepository = bookRepository;
    }

}
```

xml 태그 이용

resources 폴더에 application.xml 생성

```xml
<beans>
<bean id="bookService" class="hello.corespring.book.BookService">
        <!--이 상태로는 bookService 가 bookRepository 를 주입받지 못해.-->
        <!-- ref(레퍼런스)를 빈에 주입을 직접 해줘야 해. name의 bookRepository 는 세터에서 가져온거고, ref 는 다른 빈을 참조한다는 의미야. 그래서 ref 뒤에는 다른 빈의 아이디가 와야 해.-->
        <property name="bookRepository" ref="bookRepository" />
    </bean>
    <bean id="bookRepository" class="hello.corespring.book.BookRepository">
    </bean>
</beans>
```

main 메소드에서 등록된 bean 확인

```java
public static void main(String[] args) {
		//application.xml 을 생성했으면 사용해야지.
		ApplicationContext context = new ClassPathXmlApplicationContext("application.xml");
		String[] beanDefinitionNames = context.getBeanDefinitionNames();
		System.out.println(Arrays.toString(beanDefinitionNames)); //bean 으로 등록된 이름을 가져옴.
		BookService bookService = (BookService) context.getBean("bookService"); //그냥은 Object로 나오니까 타입 캐스팅을 해줘야 해.
		System.out.println(bookService.bookRepository != null); //True
    //의존성이 주입됐는지 확인
//근데 이거 package 가 다를 때는 못찾던데 왜 그럴까. book 패키지에 있던 service랑 repository를 main 메소드랑 같은 위치에 두니까 돌아갔음. 밑에서 작성한 component-scan 도 안되는건 같았음.
	}
```

위와 같은 방법은 일일이 bean 을 등록하는게 굉장히 번거로움.

```xml
<beans xmlns:context="http://www.springframework.org/schema/context">
	<context:component-scan base-package="hello.corespring"/>
    <!--나는 해당 패키지부터 bean 을 스캐닝 해서 등록을 하겠다. 스캐닝을 할 때는 기본적으로 component 라는 어노테이션을 사용해서 등록할 수 있음.-->
</beans>
```

```java
@Repository
public class BookRepository {
}
@Service
public class BookService {
}
```

Repository, Service 둘 다 Component 어노테이션을 확장한 어노테이션이다. 어노테이션을 달아주면 bean 으로 등록'만' 됨.

의존성 주입은 Autowired 라는 어노테이션을 사용하거나 Inject 라는 어노테이션을 사용해야 함. 근데 여기서 Inject 는 또 다른 의존성을 필요로 하기 때문에 Autowired 를 사용하기로 함.

```java
@Service
public class BookService {

    @Autowired
    BookRepository bookRepository;

    public void setBookRepository(BookRepository bookRepository) {
        this.bookRepository = bookRepository;
    }

}
```

이렇게 설정하고 나면 의존성 주입이 된 것을 확인할 수 있다. 아까와는 다르게 xml 에 등록된 component-scan 기능을 사용해서 bean 들을 패키지 이하에서 어노테이션 스캐닝 후 등록함. 스프링 2.5 부터 가능하게 된 기능. 어노테이션 기반의 빈 등록 후 설정하는 방법임.

근데 bean 설정 파일을 xml 말고 java 로 만들 수 없을까. 하고 만들어진 java bean 설정파일임.

ApplicationConfig 파일 생성

```java
@Configuration //이건 bean 설정파일이다. 라는 것을 알려주는 어노테이션임.
public class ApplicationConfig {

    @Bean
    public BookRepository bookRepository() {
        return new BookRepository();
    }

    @Bean
    public BookService bookService(BookRepository bookRepository) { //(2) 또는 메소드 파라미터로 주입받을 수도 있음.
        BookService bookService = new BookService();
        bookService.setBookRepository(bookRepository()); //의존성 주입을 해준거야. setter 가 있었기에 가능함. (1) 의존성 주입에 필요한 인스턴스는 메소드를 호출해서 가져올 수 있고.
        return bookService;
    }
}
```

main 메소드로 돌아가

```java
public static void main(String[] args) {
    ApplicationContext context = new AnnotationConfigApplicationContext(ApplicationConfig.class); //해당 클래스를 bean 설정으로 사용하겠다 선언. 
}
```

ApplicationContext 를 ClassPathXmlApplicationContext 에서 AnnotationConfigApplicationContext 로 바꾸어 설정해준다.

여기서 의존성 주입만 Autowired 를 쓰겠다, 하면

```java
public class ApplicationConfig {
       @Bean
    public BookService bookService(BookRepository bookRepository) { 
        return new BookService();
    }
}
//로 바꿔주고
public class BookService {

    @Autowired //를 추가해준다.
    BookRepository bookRepository;
}

```

위와 같은 상황은 우리가 setter 를 사용했기에 가능했지만 만약 생성자를 사용했을 경우에는 Autowired 를 해줄 수가 없고 BootService 를 생성할 때 Repository 가 불가피하게 필요하기 때문에 사용할 수 없다. 

근데 이제 java 에서도 bean 을 일일이 적어주는거 대신 component-scan 처럼 변경할 수 있다.

```java
@Configuration 
@ComponentScan(basePackageClasses = CoreSpringApplication.class) //basePackage 로 패키지명을 설정해도 되지만, basePackageClasses로 해당 클래스가 위치한 곳부터 컴포넌트 스캐닝을 해줘. 라는 의미.
public class ApplicationConfig {
}
```

그리고 service 와 repository 에 @Service , @Repository 를 추가해주고 service 클래스의 Autowired 로 의존성을 추가해주면 됨.

```java
@Service
public class BookService {
    @Autowired
    BookRepository bookRepository;
}
@Repository
public class BookRepository {
}
```

그렇지만 이 과정을 Spring Boot 가 해주기 때문에 설정파일을 만들 필요가 없다.

```java
@SpringBootApplication //사실 이것만 있으면 돼. 해당 어노테이션에는 ComponentScan 과 Configuration 이 포함되어 있기 때문에야.
public class CoreSpringApplication {
}
```

프로젝트 생성했을 때, main 메소드가 들어있는 클래스 자체가 bean 설정 파일이다.