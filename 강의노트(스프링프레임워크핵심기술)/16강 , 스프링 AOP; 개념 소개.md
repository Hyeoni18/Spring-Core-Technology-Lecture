<h3>스프링 프레임워크 핵심 기술</h3>

16강 , 스프링 AOP: 개념 소개

AOP의 구현체를 제공하며, 자바의 만들어져있는 AOP의 또 다른 구현체(Aspect)와 연동해서 사용할 수 있는 기능도 제공하고 또 스프링은 스프링 자체에서 구현한 스프링 AOP 기능도 활용할 수 있게 해줌.

그리고 이 기능을 기반으로 트랜잭션이나 다른 기능들이 적용되고 있음.

Aspect-oriendted Programming (AOP)은 OOP를 보완하는 수단으로, 흩어진 Aspect를
모듈화 할 수 있는 프로그래밍 기법.

흩어진 관심사 (Crosscutting Concerns) 

Concerns 은 여러 클래스 여러 메소드의 걸쳐서 나타나는 비슷한 코드들. 비슷한 필드를 주입된 코드들의 변경이 일어난다면 Concerns 을 사용한 모든 소스코드를 뒤져가며 코드를 손봐야해. 유지보수가 어려움. 

AOP 는 이 문제를 Aspect 를 이용하여 해결함.

흩어진 걸 하나로 모으는거지. 

![1643673818328](https://user-images.githubusercontent.com/43261300/151892962-020b4f5c-002b-44de-991a-b959533d4763.png)

AOP 주요 개념
● Aspect와 Target 
● Advice
● Join point와 Pointcut

Aspect 는 묶은거, 하나의 모듈. 여기에 들어가는게 Advice 와 Pointcut 임. Advice 는 해야할 일들. Pointcut 은 어디에 적용해야 하는지에 대한 정보.

Target 은 Class A, B, C 처럼 적용되는 대상.

 Join point 는 메소드 실행 시점임. 메소드 실행할 때 이 Advice 를 끼워 넣어줘. 다양한 시점이 있을 수 있음. 생성자 호출 직전, 생성자 호출했을 떄, 필드에 접근하기 전, 필드에서 값을 가져갔을 때 등등. 여러가지의 합류점이 있음.

그중 서브셋, 구체적인 서브셋으로 A라는 클래스에 B라는 메소드 호출할 때 Aspect X를 적용해라. 라고 알려주는게 Pointcut 임. 

그니까 Join point 는 여러 가지 합류 지점들임. 스펙에 가까운거야. 

AOP 구현체 참고 [Aspect-oriented programming - Wikipedia](https://en.wikipedia.org/wiki/Aspect-oriented_programming)

자바
○ AspectJ
○ 스프링 AOP

둘은 다름. AspectJ 는 엄청 많은 다양한 조인포인트와 기능들을 제공함. 하지만 스프링 AOP 는 매우 국한적인 기능을 제공함.

A,B,C에서 각각의 크로스 컷팅이 흩어져 있는건데. 컨선들을 이제 모듈화 했고(AspectX,Y,Z) 이걸 어떻게 적용하느냐.

AOP 적용 방법
● 컴파일
● 로드 타임
● 런타임

컴파일. 자바 파일을 클래스 파일로 만들 때 바이트 코드를 조작하면서 조작이 된 바이트 코드들을 생성해 내는거야. 그게 컴파일 타임에 AOP를 적용하는 방법이야.

예를 들어, A 클래스에 poo 라는 메소드가 있었고 AspectX 가 있어. 여기에 poo 메소드가 실행하기 전에 hello 를 출력해야 해. 이때 컴파일이 되면 클래스 파일에 hello를 찍는 메소드가 들어있어야 해. 그게 컴파일 시점에 적용하는 방법이야.

로드 타임. A 클래스는 순수하게 컴파일을 해. poo만 있는 상태야. 그런데 A 클래스를 로딩하는 시점에 클래스 정보를 변경하는 방법이 있는데, 로드 타임 위빙 이라고 부름. 로드 타임에 뭔가를 끼워넣는거야. hello 를 찍는 메소드를 낑겨 넣는거야. A 클래스 바이트 코드는 그대로 있지만 로딩한 JVM 메모리 상에서는 poo 메소드 전에 hello 메소드가 같이 들어있는 상태로 로딩된거지.

런타임. 스프링 AOP가 사용하는 방법. A 클래스에, 스프링 AOP 니까 bean 이라고 부를거야. A라는 bean 에 AspectX 를 적용해야 한다는 것을 스프링이 알고 있어. 그래서 A 클래스 타입의 bean 을 만들 때 A 타입의 프록시 빈을 만들어. 이 프록시 빈이 실제 A가 가지고 있는 poo 라는 메소드를 호출하기 직전에 hello 메소드를 호출하고 그 다음에 A를 호출해. 다음 수업에서 좀 더 자세하게 설명.

컴파일 때 적용을 하면 런타임이나 로드 타임 때 성능적인 부하가 없겠지. 근데 그럴려면 별도의 컴파일을 한 번 더 해야 해.

로드 타임은 약간의 성능적 부하랑 로드타임 위버를 설정해야 하는거. 다양하게 표현할 수 있음. AspectJ 도 쓸 수 있고.

런타임은 초기 빈을 만들 때 성능이 추가되지만, 아무런 설정이 필요없다는거. 별도의 컴파일이나 로드타임 위버 설정. 그리고 문법이 쉽고 AOP 공부를 많이 할 필요도 없음.

컴파일이나 로드타임은 AspectJ 를 사용할 때, 런타임은 스프링 AOP 를 사용할 때 쓰는 방법이 될거야.